<!DOCTYPE html>
<html>
<head>
    <title>terrain</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            line-height: 1;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #terminal {
            white-space: pre;
            letter-spacing: 2px;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <script>
        // Configuration
        const WIDTH = 80;
        const HEIGHT = 30;
        const SCROLL_SPEED = 1;
        const FRAME_RATE = 15;
        
        // Enhanced terrain types for island/water focus
        const TERRAIN_TYPES = [
            { name: 'deep_water', char: '≈', color: '#000080', weight: 0.3, height: -2 },
            { name: 'shallow_water', char: '~', color: '#1E90FF', weight: 0.2, height: -1 },
            { name: 'sand', char: '░', color: '#F0E68C', weight: 0.1, height: 0 },
            { name: 'grass', char: '▓', color: '#32CD32', weight: 0.15, height: 1 },
            { name: 'forest', char: '♠', color: '#006400', weight: 0.15, height: 2 },
            { name: 'mountain', char: '▲', color: '#808080', weight: 0.05, height: 3 },
            { name: 'snow', char: '❄', color: '#FFFFFF', weight: 0.05, height: 4 }
        ];

        class IslandTerrainGenerator {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.grid = [];
                this.currentRow = this.generateInitialRow();
                this.scrollOffset = 0;
                this.landBias = 0.5; // Start with neutral bias
                this.biomeCenter = Math.floor(width / 2);
                this.riverPosition = Math.floor(width * 0.3);
                this.riverWidth = 3;
                
                // Initialize grid
                for (let y = 0; y < height; y++) {
                    this.grid.push(this.generateNextRow());
                }
            }
            
            generateInitialRow() {
                return Array.from({length: this.width}, () => 
                    this.weightedRandomTerrain(TERRAIN_TYPES)
                );
            }
            
            weightedRandomTerrain(options) {
                const totalWeight = options.reduce((sum, t) => sum + t.weight, 0);
                let random = Math.random() * totalWeight;
                let weightSum = 0;
                
                for (const option of options) {
                    weightSum += option.weight;
                    if (random <= weightSum) return option;
                }
                
                return options[0];
            }
            
            generateNextRow() {
                // Slowly drift the land bias and river position
                this.landBias += (Math.random() - 0.5) * 0.05;
                this.landBias = Math.max(0.2, Math.min(0.8, this.landBias));
                
                this.biomeCenter += (Math.random() - 0.5) * 2;
                this.biomeCenter = Math.max(10, Math.min(this.width - 10, this.biomeCenter));
                
                this.riverPosition += (Math.random() - 0.5) * 0.5;
                this.riverPosition = Math.max(5, Math.min(this.width - 5, this.riverPosition));
                
                const newRow = [];
                
                for (let x = 0; x < this.width; x++) {
                    // Calculate distance from biome center
                    const distanceFromCenter = Math.abs(x - this.biomeCenter);
                    const normalizedDistance = distanceFromCenter / (this.width / 2);
                    
                    // Calculate distance from river
                    const distanceFromRiver = Math.abs(x - this.riverPosition);
                    const isRiver = distanceFromRiver < this.riverWidth;
                    
                    // Get neighbors for cohesion
                    const left = this.currentRow[x-1] || this.currentRow[x];
                    const right = this.currentRow[x+1] || this.currentRow[x];
                    const avgHeight = (left.height + this.currentRow[x].height + right.height) / 3;
                    
                    // Create adjusted weights based on multiple factors
                    let weights = TERRAIN_TYPES.map(t => {
                        let weight = t.weight;
                        
                        // Apply land/water bias
                        if (t.height >= 0) weight *= this.landBias;
                        else weight *= (1 - this.landBias);
                        
                        // Apply biome center effect (more land near center)
                        if (t.height >= 0) weight *= (1 - normalizedDistance * 0.7);
                        
                        // River effect
                        if (isRiver) {
                            if (t.name.includes('water')) weight *= 3;
                            else weight *= 0.3;
                        }
                        
                        // Height cohesion
                        if (Math.abs(t.height - avgHeight) > 1.5) weight *= 0.3;
                        
                        return weight;
                    });
                    
                    // Ensure we don't have zero weights
                    const minWeight = 0.001;
                    weights = weights.map(w => Math.max(w, minWeight));
                    
                    // Create temporary terrain types with adjusted weights
                    const adjustedTypes = TERRAIN_TYPES.map((t, i) => 
                        ({...t, weight: weights[i]})
                    );
                    
                    newRow.push(this.weightedRandomTerrain(adjustedTypes));
                }
                
                this.currentRow = newRow;
                return newRow;
            }
            
            scroll() {
                this.scrollOffset += SCROLL_SPEED;
                
                if (this.scrollOffset >= 1) {
                    this.scrollOffset = 0;
                    this.grid.shift();
                    this.grid.push(this.generateNextRow());
                }
            }
            
            render(container) {
                let output = '';
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const terrain = this.grid[y][x];
                        output += `<span style="color:${terrain.color}">${terrain.char}</span>`;
                    }
                    output += '\n';
                }
                
                container.innerHTML = output;
            }
        }

        // Initialize and run
        const terminal = document.getElementById('terminal');
        const generator = new IslandTerrainGenerator(WIDTH, HEIGHT);
        
        function gameLoop() {
            generator.scroll();
            generator.render(terminal);
            setTimeout(gameLoop, 1000 / FRAME_RATE);
        }
        
        gameLoop();
        
        // Handle window resize
        function resize() {
            const cols = Math.floor(window.innerWidth / 12);
            const rows = Math.floor(window.innerHeight / 18);
            
            terminal.style.fontSize = `${Math.min(
                window.innerWidth / cols * 1.5, 
                window.innerHeight / rows * 1.5
            )}px`;
        }
        
        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
